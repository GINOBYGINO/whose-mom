<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¶ è‰²ç›¸ç°¿è¶´ v0.2</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary-green: #2ecc71;
            --dark-green: #1b5e20;
            --bg-grad: linear-gradient(135deg, #05140b 0%, #0d2b1a 100%);
            --card-grad: linear-gradient(180deg, #1e2d24 0%, #152019 100%);
            --text-color: #e0e8e3;
            --accent-yellow: #f1c40f;
            --error-red: #ff4757;
        }

        body {
            font-family: 'Segoe UI', "Microsoft JhengHei", sans-serif;
            background: var(--bg-grad);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            width: 90%;
            max-width: 500px;
            padding: 20px;
            text-align: center;
        }

        .card {
            background: var(--card-grad);
            border-radius: 24px;
            padding: 25px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 1px rgba(255,255,255,0.05);
            margin-top: 20px;
            border: 1px solid rgba(46, 204, 113, 0.2);
            position: relative;
        }

        /* å¢åŠ ç™¼å…‰æ•ˆæœ */
        .card::after {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, transparent, rgba(46, 204, 113, 0.1), transparent);
            z-index: -1;
            border-radius: 26px;
        }

        h1 { 
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .hidden { display: none !important; }

        input[type="text"] {
            width: 85%;
            padding: 14px;
            margin: 10px 0;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--primary-green);
            border-radius: 12px;
            color: white;
            outline: none;
            transition: box-shadow 0.3s;
        }
        input[type="text"]:focus { box-shadow: 0 0 10px rgba(46, 204, 113, 0.4); }

        button {
            background: linear-gradient(180deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            font-size: 1rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        button:active { transform: translateY(1px); }
        button:disabled { background: #444; color: #888; transform: none; box-shadow: none; }

        .timer { font-size: 2.5rem; font-weight: 800; color: var(--accent-yellow); margin: 10px 0; text-shadow: 0 0 10px rgba(241, 196, 15, 0.3); }
        
        .photo-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 20px; }
        .photo-item img { width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 12px; border: 3px solid transparent; transition: 0.3s; }
        .selected { border-color: var(--accent-yellow) !important; transform: scale(1.02); }
        
        .status-badge { background: rgba(46, 204, 113, 0.1); padding: 8px 16px; border-radius: 50px; border: 1px solid rgba(46, 204, 113, 0.3); margin: 5px; font-size: 0.9rem; }
        .version-tag { position: fixed; bottom: 10px; right: 15px; font-size: 0.75rem; color: rgba(255,255,255,0.2); }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ€ ç¶ è‰²ç›¸ç°¿è¶´</h1>
    
    <div id="view-lobby" class="view">
        <div class="card">
            <h3>éŠæˆ²ç™»å…¥</h3>
            <input type="text" id="player-name" placeholder="è¼¸å…¥æš±ç¨±...">
            <br>
            <button onclick="createRoom()">å»ºç«‹æ–°æˆ¿é–“</button>
            <div style="margin: 20px 0; color: #555;">â”€â”€â”€ æˆ–è€… â”€â”€â”€</div>
            <input type="text" id="room-id-input" placeholder="è¼¸å…¥æˆ¿è™Ÿ (ID)...">
            <button onclick="joinRoom()">åŠ å…¥å¥½å‹æˆ¿é–“</button>
        </div>
    </div>

    <div id="view-waiting" class="view hidden">
        <div class="card">
            <p>æˆ¿é–“ä»£ç¢¼</p>
            <h2 id="display-room-id" style="color:var(--accent-yellow); letter-spacing: 2px;">-</h2>
            <p>å·²æº–å‚™ç©å®¶ (<span id="player-count">0</span>/6)</p>
            <div id="player-list" style="display:flex; flex-wrap:wrap; justify-content:center;"></div>
            <div style="margin-top: 30px;">
                <button id="start-game-btn" class="hidden" onclick="hostStartGame()">å…¨å“¡åˆ°é½Šï¼Œé–‹æˆ°ï¼</button>
            </div>
        </div>
    </div>

    <div id="view-game" class="view hidden">
        <div class="card">
            <div id="sub-waiting-topic" class="sub-view">
                <h3 style="color:var(--accent-yellow)">ç­‰å¾…é ˜è¢–å‡ºé¡Œ...</h3>
                <p id="current-leader-name"></p>
            </div>

            <div id="sub-leader-input" class="sub-view hidden">
                <h3>ä½ æ˜¯æœ¬è¼ªé ˜è¢–ï¼</h3>
                <p>è«‹å‡ºä¸€å€‹é¡Œç›®ï¼Œè®“å¤§å®¶å¾ç›¸ç°¿æ‰¾åœ–</p>
                <input type="text" id="topic-input" placeholder="ä¾‹å¦‚ï¼šé€™ç…§ç‰‡çœ‹èµ·ä¾†å¾ˆæœ‰å‘³é“">
                <br>
                <button onclick="submitTopicToServer()">ç™¼å¸ƒé¡Œç›®</button>
            </div>

            <div id="sub-upload" class="sub-view hidden">
                <p>é¡Œç›®ï¼š</p>
                <h2 id="display-topic" style="color:var(--primary-green)"></h2>
                <div class="timer" id="upload-timer">50</div>
                <div id="upload-controls">
                    <input type="file" id="photo-input" accept="image/*" style="margin: 10px 0; color: #888;">
                    <br>
                    <button onclick="processAndUpload()">ç¢ºèªä¸Šå‚³ç…§ç‰‡</button>
                </div>
                <div id="upload-msg" class="hidden">å·²æˆåŠŸé€å‡ºï¼Œç­‰å¾…å…¶ä»–ç©å®¶...</div>
            </div>

            <div id="sub-voting" class="sub-view hidden">
                <h3 id="voting-instruction" style="color:var(--accent-yellow)"></h3>
                <div class="timer" id="vote-timer">20</div>
                <div class="photo-grid" id="voting-grid"></div>
                <br>
                <button id="btn-submit-vote" onclick="submitVoteToServer()">ç¢ºèªæŠ•ç¥¨</button>
            </div>

            <div id="sub-results" class="sub-view hidden">
                <h3>å›åˆè¨ˆåˆ†</h3>
                <div id="round-rank" style="font-size: 1.2rem; line-height: 2.5;"></div>
            </div>
        </div>
    </div>

    <div id="view-final" class="view hidden">
        <div class="card">
            <h2 style="color:var(--accent-yellow)">ğŸ† æœ€çµ‚æ¦®è€€ ğŸ†</h2>
            <div id="final-leaderboard"></div>
            <button onclick="location.reload()" style="margin-top:20px">å›é¦–é </button>
        </div>
    </div>
</div>

<div class="version-tag">v0.2 | Peer-to-Peer </div>

<script>
    let peer, conn, roomId;
    let myName = "";
    let isHost = false;
    let players = []; 
    let currentRound = 0;
    let currentLeaderId = "";
    let timerInterval;

    // --- åˆå§‹åŒ–èˆ‡é€£ç·š ---
    function createRoom() {
        myName = document.getElementById('player-name').value.trim() || "æˆ¿ä¸»";
        peer = new Peer();
        peer.on('open', id => {
            isHost = true;
            roomId = id;
            document.getElementById('display-room-id').innerText = id;
            players.push({ id: id, name: myName, score: 0, photo: null, votes: 0 });
            updateLobbyUI();
            switchView('view-waiting');
            document.getElementById('start-game-btn').classList.remove('hidden');
        });
        peer.on('connection', c => {
            c.on('open', () => {
                c.on('data', data => handleData(data, c));
            });
        });
    }

    function joinRoom() {
        myName = document.getElementById('player-name').value.trim() || "ç©å®¶";
        roomId = document.getElementById('room-id-input').value.trim();
        if (!roomId) return alert("è«‹è¼¸å…¥æˆ¿è™Ÿ");
        
        peer = new Peer();
        peer.on('open', id => {
            conn = peer.connect(roomId);
            conn.on('open', () => {
                conn.send({ type: 'JOIN_REQ', name: myName });
            });
            conn.on('data', data => handleData(data));
        });
    }

    // --- è¨Šæ¯è™•ç†æ ¸å¿ƒ ---
    function handleData(data, connection) {
        console.log("Receive:", data.type, data);
        switch(data.type) {
            case 'JOIN_REQ':
                if (isHost) {
                    // (1) æª¢æŸ¥æ˜¯å¦é‡è¤‡
                    if (players.find(p => p.id === connection.peer || p.name === data.name)) {
                        connection.send({ type: 'ERROR', msg: 'åç¨±å·²å­˜åœ¨æˆ–å·²åœ¨æˆ¿é–“ä¸­' });
                        return;
                    }
                    players.push({ id: connection.peer, name: data.name, score: 0, photo: null, votes: 0, peerConn: connection });
                    broadcast({ type: 'SYNC_LOBBY', players: players.map(p => ({name: p.name})) });
                    updateLobbyUI();
                }
                break;
            case 'SYNC_LOBBY':
                updateLobbyUI(data.players);
                switchView('view-waiting');
                document.getElementById('display-room-id').innerText = roomId;
                break;
            case 'GAME_STATE': // å¼·åˆ¶ç‹€æ…‹åŒæ­¥
                syncGameState(data);
                break;
            case 'CLIENT_SUBMIT_TOPIC': // é ˜è¢–(Client)ç™¼é¡Œç›®çµ¦ Host
                if (isHost) startUploadPhase(data.topic);
                break;
            case 'UPLOAD_PHOTO': // ç©å®¶ç™¼ç…§ç‰‡çµ¦ Host
                if (isHost) {
                    let p = players.find(x => x.id === connection.peer);
                    if(p) p.photo = data.photo;
                    checkAllPhotosStatus();
                }
                break;
            case 'VOTE_SUBMIT':
                if (isHost) recordVote(data, connection.peer);
                break;
            case 'ERROR':
                alert(data.msg);
                location.reload();
                break;
        }
    }

    function broadcast(data) {
        players.forEach(p => { if (p.peerConn) p.peerConn.send(data); });
    }

    // --- æµç¨‹æ§åˆ¶ ---
    function hostStartGame() {
        if (players.length < 3) return alert("è‡³å°‘éœ€è¦ 3 äºº");
        currentRound = 0;
        nextRound();
    }

    function nextRound() {
        const totalRoundsNeeded = players.length * 2;
        if (currentRound >= totalRoundsNeeded) {
            broadcast({ type: 'GAME_STATE', phase: 'FINAL', players: players });
            syncGameState({ phase: 'FINAL', players: players });
            return;
        }

        // é‡ç½®å›åˆç‹€æ…‹
        players.forEach(p => { p.photo = null; p.votes = 0; p.voted = false; });
        const leader = players[currentRound % players.length];
        currentLeaderId = leader.id;
        currentRound++;

        broadcast({ 
            type: 'GAME_STATE', 
            phase: 'WAIT_TOPIC', 
            leaderId: leader.id, 
            leaderName: leader.name 
        });
        syncGameState({ phase: 'WAIT_TOPIC', leaderId: leader.id, leaderName: leader.name });
    }

    function syncGameState(data) {
        switchView('view-game');
        document.querySelectorAll('.sub-view').forEach(s => s.classList.add('hidden'));

        if (data.phase === 'WAIT_TOPIC') {
            if (peer.id === data.leaderId) {
                showSubView('sub-leader-input');
            } else {
                showSubView('sub-waiting-topic');
                document.getElementById('current-leader-name').innerText = `ç¾åœ¨é ˜è¢–æ˜¯ï¼š${data.leaderName}`;
            }
        } 
        else if (data.phase === 'UPLOADING') {
            showSubView('sub-upload');
            document.getElementById('display-topic').innerText = data.topic;
            document.getElementById('upload-controls').classList.toggle('hidden', peer.id === data.leaderId);
            document.getElementById('upload-msg').classList.toggle('hidden', peer.id !== data.leaderId);
            if (peer.id === data.leaderId) document.getElementById('upload-msg').innerText = "ä½ æ˜¯é ˜è¢–ï¼Œç­‰å¾…å¤§å®¶æŒ‘é¸ç…§ç‰‡...";
            startTimer(50, () => { if(isHost) checkAllPhotosStatus(); }, 'upload-timer');
        }
        else if (data.phase === 'VOTING') {
            showSubView('sub-voting');
            renderVotingGrid(data.photos);
            const amILeader = peer.id === data.leaderId;
            document.getElementById('voting-instruction').innerText = amILeader ? "ä½ æ˜¯é ˜è¢–ï¼šæŒ‘ä¸€å¼µæœ€å–œæ­¡çš„ (+2åˆ†)" : "æŒ‘ä¸€å¼µæœ€ä¸å–œæ­¡çš„ç…§ç‰‡ (-1åˆ†)";
            startTimer(20, () => submitVoteToServer(), 'vote-timer');
        }
        else if (data.phase === 'RESULTS') {
            showSubView('sub-results');
            renderResults(data.players);
        }
        else if (data.phase === 'FINAL') {
            switchView('view-final');
            renderFinal(data.players);
        }
    }

    function submitTopicToServer() {
        const topic = document.getElementById('topic-input').value.trim();
        if (!topic) return;
        if (isHost) startUploadPhase(topic);
        else conn.send({ type: 'CLIENT_SUBMIT_TOPIC', topic: topic });
    }

    function startUploadPhase(topic) {
        broadcast({ type: 'GAME_STATE', phase: 'UPLOADING', topic: topic, leaderId: currentLeaderId });
        syncGameState({ phase: 'UPLOADING', topic: topic, leaderId: currentLeaderId });
    }

    function processAndUpload() {
        const fileInput = document.getElementById('photo-input');
        if (!fileInput.files[0]) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const scale = Math.min(500 / img.width, 500 / img.height);
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.5);

                if (isHost) {
                    players.find(p => p.id === peer.id).photo = dataUrl;
                    checkAllPhotosStatus();
                } else {
                    conn.send({ type: 'UPLOAD_PHOTO', photo: dataUrl });
                }
                document.getElementById('upload-controls').classList.add('hidden');
                document.getElementById('upload-msg').classList.remove('hidden');
                document.getElementById('upload-msg').innerText = "ç…§ç‰‡å·²ç™¼é€ï¼";
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(fileInput.files[0]);
    }

    function checkAllPhotosStatus() {
        const others = players.filter(p => p.id !== currentLeaderId);
        if (others.every(p => p.photo)) {
            const photos = others.map(p => ({ id: p.id, img: p.photo })).sort(() => Math.random() - 0.5);
            broadcast({ type: 'GAME_STATE', phase: 'VOTING', photos: photos, leaderId: currentLeaderId });
            syncGameState({ phase: 'VOTING', photos: photos, leaderId: currentLeaderId });
        }
    }

    function renderVotingGrid(photos) {
        const grid = document.getElementById('voting-grid');
        grid.innerHTML = "";
        let selectedId = null;
        photos.forEach(p => {
            const img = document.createElement('img');
            img.src = p.img;
            img.onclick = () => {
                grid.querySelectorAll('img').forEach(i => i.classList.remove('selected'));
                img.classList.add('selected');
                window.selectedPhotoId = p.id;
            };
            grid.appendChild(img);
        });
    }

    function submitVoteToServer() {
        const voteData = { type: 'VOTE_SUBMIT', targetId: window.selectedPhotoId, isLeaderVote: peer.id === currentLeaderId };
        if (isHost) recordVote(voteData, peer.id);
        else conn.send(voteData);
        document.getElementById('sub-voting').innerHTML = "<h3>å·²é€å‡ºæŠ•ç¥¨ï¼Œè«‹ç¨å€™...</h3>";
    }

    function recordVote(data, voterId) {
        let voter = players.find(p => p.id === voterId);
        if (voter.voted) return;
        voter.voted = true;

        if (data.isLeaderVote && data.targetId) {
            let target = players.find(p => p.id === data.targetId);
            if(target) target.score += 2;
        } else if (data.targetId) {
            let target = players.find(p => p.id === data.targetId);
            if(target) target.votes += 1;
        }

        if (players.every(p => p.voted)) {
            // è¨ˆç®—æ‰£åˆ†
            const others = players.filter(p => p.id !== currentLeaderId);
            const maxV = Math.max(...others.map(o => o.votes));
            const losers = others.filter(o => o.votes === maxV);
            if (maxV > 0 && losers.length === 1) {
                losers[0].score = Math.max(0, losers[0].score - 1);
            }
            broadcast({ type: 'GAME_STATE', phase: 'RESULTS', players: players.map(p => ({name: p.name, score: p.score})) });
            syncGameState({ phase: 'RESULTS', players: players });
            setTimeout(() => nextRound(), 6000);
        }
    }

    // --- UI Helpers ---
    function switchView(id) {
        document.querySelectorAll('.view').forEach(v => v.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }
    function showSubView(id) {
        document.querySelectorAll('.sub-view').forEach(s => s.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }
    function updateLobbyUI(pList) {
        const list = pList || players;
        document.getElementById('player-count').innerText = list.length;
        document.getElementById('player-list').innerHTML = list.map(p => `<span class="status-badge">${p.name}</span>`).join('');
    }
    function startTimer(sec, callback, elId) {
        let t = sec;
        const el = document.getElementById(elId);
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            t--;
            if(el) el.innerText = t;
            if(t <= 0) { clearInterval(timerInterval); callback(); }
        }, 1000);
    }
    function renderResults(pList) {
        const list = [...pList].sort((a,b) => b.score - a.score);
        document.getElementById('round-rank').innerHTML = list.map(p => `<div>${p.name} : <span style="color:var(--primary-green)">${p.score}</span> åˆ†</div>`).join('');
    }
    function renderFinal(pList) {
        const list = [...pList].sort((a,b) => b.score - a.score);
        document.getElementById('final-leaderboard').innerHTML = list.map((p,i) => `<h3>ç¬¬ ${i+1} å: ${p.name} (${p.score}åˆ†)</h3>`).join('');
    }
</script>
</body>
</html>
